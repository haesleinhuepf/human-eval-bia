{"task_id": "../test_cases/apply_otsu_threshold_and_count_postiive_pixels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result"}
{"task_id": "../test_cases/binary_closing.ipynb", "completion": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))", "full_response": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))"}
{"task_id": "../test_cases/binary_skeleton.ipynb", "completion": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)", "full_response": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)"}
{"task_id": "../test_cases/bland_altman.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe"}
{"task_id": "../test_cases/combine_columns_of_tables.ipynb", "completion": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')", "full_response": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')"}
{"task_id": "../test_cases/convex_hull_measure_area.ipynb", "completion": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()", "full_response": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()"}
{"task_id": "../test_cases/convolve_images.ipynb", "completion": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    ", "full_response": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    "}
{"task_id": "../test_cases/count_number_of_touching_neighbors.ipynb", "completion": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]", "full_response": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]"}
{"task_id": "../test_cases/count_objects_over_time.ipynb", "completion": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]", "full_response": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]"}
{"task_id": "../test_cases/count_overlapping_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()"}
{"task_id": "../test_cases/create_umap.ipynb", "completion": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value", "full_response": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value"}
{"task_id": "../test_cases/crop_quarter_image.ipynb", "completion": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]", "full_response": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]"}
{"task_id": "../test_cases/deconvolve_image.ipynb", "completion": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    ", "full_response": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    "}
{"task_id": "../test_cases/detect_edges.ipynb", "completion": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image"}
{"task_id": "../test_cases/expand_labels_without_overlap.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)", "full_response": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)"}
{"task_id": "../test_cases/extract_surface_measure_area.ipynb", "completion": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()", "full_response": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()"}
{"task_id": "../test_cases/fit_circle.ipynb", "completion": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r", "full_response": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r"}
{"task_id": "../test_cases/label_binary_image_and_count_labels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1", "full_response": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1"}
{"task_id": "../test_cases/label_sequentially.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]", "full_response": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]"}
{"task_id": "../test_cases/list_image_files_in_folder.ipynb", "completion": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]", "full_response": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]"}
{"task_id": "../test_cases/map_pixel_count_of_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)"}
{"task_id": "../test_cases/mask_image.ipynb", "completion": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask", "full_response": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask"}
{"task_id": "../test_cases/maximum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)"}
{"task_id": "../test_cases/mean_squared_error.ipynb", "completion": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy", "full_response": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy"}
{"task_id": "../test_cases/mean_std_column.ipynb", "completion": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)", "full_response": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)"}
{"task_id": "../test_cases/measure_aspect_ratio_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats"}
{"task_id": "../test_cases/measure_intensity_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]"}
{"task_id": "../test_cases/measure_intensity_over_time.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))", "full_response": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))"}
{"task_id": "../test_cases/measure_mean_image_intensity.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).mean()", "full_response": "\n    import numpy as np\n    return np.asarray(image).mean()"}
{"task_id": "../test_cases/measure_pixel_count_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]"}
{"task_id": "../test_cases/measure_properties_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)"}
{"task_id": "../test_cases/open_image_read_voxel_size.ipynb", "completion": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X", "full_response": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X"}
{"task_id": "../test_cases/open_image_return_dimensions.ipynb", "completion": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape", "full_response": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape"}
{"task_id": "../test_cases/open_nifti_image.ipynb", "completion": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)", "full_response": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)"}
{"task_id": "../test_cases/open_zarr.ipynb", "completion": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array", "full_response": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array"}
{"task_id": "../test_cases/pair_wise_correlation_matrix.ipynb", "completion": "\n    return dataframe.corr()", "full_response": "\n    return dataframe.corr()"}
{"task_id": "../test_cases/radial_intensity_profile.ipynb", "completion": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile ", "full_response": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile "}
{"task_id": "../test_cases/region_growing_segmentation.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.flood(image, point)", "full_response": "\n    import skimage\n    return skimage.segmentation.flood(image, point)"}
{"task_id": "../test_cases/remove_labels_on_edges.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)", "full_response": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)"}
{"task_id": "../test_cases/remove_noise_edge_preserving.ipynb", "completion": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image"}
{"task_id": "../test_cases/remove_small_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)"}
{"task_id": "../test_cases/return_hello_world.ipynb", "completion": "\n    return \"hello world\"", "full_response": "\n    return \"hello world\""}
{"task_id": "../test_cases/rgb_to_grey_image_transform.ipynb", "completion": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image", "full_response": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image"}
{"task_id": "../test_cases/rotate_image_by_90_degrees.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)"}
{"task_id": "../test_cases/subsample_image.ipynb", "completion": "\n    return image[::n,::n]", "full_response": "\n    return image[::n,::n]"}
{"task_id": "../test_cases/subtract_background_tophat.ipynb", "completion": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image", "full_response": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image"}
{"task_id": "../test_cases/sum_images.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)", "full_response": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)"}
{"task_id": "../test_cases/sum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)"}
{"task_id": "../test_cases/tiled_image_processing.ipynb", "completion": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result", "full_response": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result"}
{"task_id": "../test_cases/transpose_image_axes.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).T", "full_response": "\n    import numpy as np\n    return np.asarray(image).T"}
{"task_id": "../test_cases/t_test.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    ", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    "}
{"task_id": "../test_cases/workflow_batch_process_folder_count_labels.ipynb", "completion": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result", "full_response": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result"}
{"task_id": "../test_cases/workflow_batch_process_folder_measure_intensity.ipynb", "completion": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)", "full_response": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)"}
{"task_id": "../test_cases/workflow_segmentation_counting.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()", "full_response": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()"}
{"task_id": "../test_cases/workflow_segmentation_measurement_summary.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)"}
{"task_id": "../test_cases/workflow_segment_measure_umap.ipynb", "completion": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe", "full_response": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe"}
{"task_id": "../test_cases/workflow_watershed_segmentation_correction_measurement.ipynb", "completion": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()", "full_response": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()"}
{"task_id": "../test_cases/apply_otsu_threshold_and_count_postiive_pixels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result"}
{"task_id": "../test_cases/binary_closing.ipynb", "completion": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))", "full_response": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))"}
{"task_id": "../test_cases/binary_skeleton.ipynb", "completion": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)", "full_response": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)"}
{"task_id": "../test_cases/bland_altman.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe"}
{"task_id": "../test_cases/combine_columns_of_tables.ipynb", "completion": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')", "full_response": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')"}
{"task_id": "../test_cases/convex_hull_measure_area.ipynb", "completion": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()", "full_response": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()"}
{"task_id": "../test_cases/convolve_images.ipynb", "completion": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    ", "full_response": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    "}
{"task_id": "../test_cases/count_number_of_touching_neighbors.ipynb", "completion": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]", "full_response": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]"}
{"task_id": "../test_cases/count_objects_over_time.ipynb", "completion": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]", "full_response": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]"}
{"task_id": "../test_cases/count_overlapping_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()"}
{"task_id": "../test_cases/create_umap.ipynb", "completion": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value", "full_response": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value"}
{"task_id": "../test_cases/crop_quarter_image.ipynb", "completion": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]", "full_response": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]"}
{"task_id": "../test_cases/deconvolve_image.ipynb", "completion": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    ", "full_response": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    "}
{"task_id": "../test_cases/detect_edges.ipynb", "completion": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image"}
{"task_id": "../test_cases/expand_labels_without_overlap.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)", "full_response": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)"}
{"task_id": "../test_cases/extract_surface_measure_area.ipynb", "completion": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()", "full_response": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()"}
{"task_id": "../test_cases/fit_circle.ipynb", "completion": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r", "full_response": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r"}
{"task_id": "../test_cases/label_binary_image_and_count_labels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1", "full_response": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1"}
{"task_id": "../test_cases/label_sequentially.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]", "full_response": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]"}
{"task_id": "../test_cases/list_image_files_in_folder.ipynb", "completion": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]", "full_response": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]"}
{"task_id": "../test_cases/map_pixel_count_of_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)"}
{"task_id": "../test_cases/mask_image.ipynb", "completion": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask", "full_response": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask"}
{"task_id": "../test_cases/maximum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)"}
{"task_id": "../test_cases/mean_squared_error.ipynb", "completion": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy", "full_response": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy"}
{"task_id": "../test_cases/mean_std_column.ipynb", "completion": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)", "full_response": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)"}
{"task_id": "../test_cases/measure_aspect_ratio_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats"}
{"task_id": "../test_cases/measure_intensity_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]"}
{"task_id": "../test_cases/measure_intensity_over_time.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))", "full_response": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))"}
{"task_id": "../test_cases/measure_mean_image_intensity.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).mean()", "full_response": "\n    import numpy as np\n    return np.asarray(image).mean()"}
{"task_id": "../test_cases/measure_pixel_count_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]"}
{"task_id": "../test_cases/measure_properties_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)"}
{"task_id": "../test_cases/open_image_read_voxel_size.ipynb", "completion": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X", "full_response": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X"}
{"task_id": "../test_cases/open_image_return_dimensions.ipynb", "completion": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape", "full_response": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape"}
{"task_id": "../test_cases/open_nifti_image.ipynb", "completion": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)", "full_response": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)"}
{"task_id": "../test_cases/open_zarr.ipynb", "completion": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array", "full_response": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array"}
{"task_id": "../test_cases/pair_wise_correlation_matrix.ipynb", "completion": "\n    return dataframe.corr()", "full_response": "\n    return dataframe.corr()"}
{"task_id": "../test_cases/radial_intensity_profile.ipynb", "completion": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile ", "full_response": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile "}
{"task_id": "../test_cases/region_growing_segmentation.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.flood(image, point)", "full_response": "\n    import skimage\n    return skimage.segmentation.flood(image, point)"}
{"task_id": "../test_cases/remove_labels_on_edges.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)", "full_response": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)"}
{"task_id": "../test_cases/remove_noise_edge_preserving.ipynb", "completion": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image"}
{"task_id": "../test_cases/remove_small_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)"}
{"task_id": "../test_cases/return_hello_world.ipynb", "completion": "\n    return \"hello world\"", "full_response": "\n    return \"hello world\""}
{"task_id": "../test_cases/rgb_to_grey_image_transform.ipynb", "completion": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image", "full_response": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image"}
{"task_id": "../test_cases/rotate_image_by_90_degrees.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)"}
{"task_id": "../test_cases/subsample_image.ipynb", "completion": "\n    return image[::n,::n]", "full_response": "\n    return image[::n,::n]"}
{"task_id": "../test_cases/subtract_background_tophat.ipynb", "completion": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image", "full_response": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image"}
{"task_id": "../test_cases/sum_images.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)", "full_response": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)"}
{"task_id": "../test_cases/sum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)"}
{"task_id": "../test_cases/tiled_image_processing.ipynb", "completion": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result", "full_response": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result"}
{"task_id": "../test_cases/transpose_image_axes.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).T", "full_response": "\n    import numpy as np\n    return np.asarray(image).T"}
{"task_id": "../test_cases/t_test.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    ", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    "}
{"task_id": "../test_cases/workflow_batch_process_folder_count_labels.ipynb", "completion": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result", "full_response": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result"}
{"task_id": "../test_cases/workflow_batch_process_folder_measure_intensity.ipynb", "completion": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)", "full_response": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)"}
{"task_id": "../test_cases/workflow_segmentation_counting.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()", "full_response": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()"}
{"task_id": "../test_cases/workflow_segmentation_measurement_summary.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)"}
{"task_id": "../test_cases/workflow_segment_measure_umap.ipynb", "completion": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe", "full_response": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe"}
{"task_id": "../test_cases/workflow_watershed_segmentation_correction_measurement.ipynb", "completion": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()", "full_response": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()"}
{"task_id": "../test_cases/apply_otsu_threshold_and_count_postiive_pixels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result"}
{"task_id": "../test_cases/binary_closing.ipynb", "completion": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))", "full_response": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))"}
{"task_id": "../test_cases/binary_skeleton.ipynb", "completion": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)", "full_response": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)"}
{"task_id": "../test_cases/bland_altman.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe"}
{"task_id": "../test_cases/combine_columns_of_tables.ipynb", "completion": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')", "full_response": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')"}
{"task_id": "../test_cases/convex_hull_measure_area.ipynb", "completion": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()", "full_response": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()"}
{"task_id": "../test_cases/convolve_images.ipynb", "completion": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    ", "full_response": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    "}
{"task_id": "../test_cases/count_number_of_touching_neighbors.ipynb", "completion": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]", "full_response": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]"}
{"task_id": "../test_cases/count_objects_over_time.ipynb", "completion": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]", "full_response": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]"}
{"task_id": "../test_cases/count_overlapping_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()"}
{"task_id": "../test_cases/create_umap.ipynb", "completion": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value", "full_response": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value"}
{"task_id": "../test_cases/crop_quarter_image.ipynb", "completion": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]", "full_response": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]"}
{"task_id": "../test_cases/deconvolve_image.ipynb", "completion": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    ", "full_response": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    "}
{"task_id": "../test_cases/detect_edges.ipynb", "completion": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image"}
{"task_id": "../test_cases/expand_labels_without_overlap.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)", "full_response": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)"}
{"task_id": "../test_cases/extract_surface_measure_area.ipynb", "completion": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()", "full_response": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()"}
{"task_id": "../test_cases/fit_circle.ipynb", "completion": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r", "full_response": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r"}
{"task_id": "../test_cases/label_binary_image_and_count_labels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1", "full_response": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1"}
{"task_id": "../test_cases/label_sequentially.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]", "full_response": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]"}
{"task_id": "../test_cases/list_image_files_in_folder.ipynb", "completion": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]", "full_response": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]"}
{"task_id": "../test_cases/map_pixel_count_of_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)"}
{"task_id": "../test_cases/mask_image.ipynb", "completion": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask", "full_response": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask"}
{"task_id": "../test_cases/maximum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)"}
{"task_id": "../test_cases/mean_squared_error.ipynb", "completion": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy", "full_response": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy"}
{"task_id": "../test_cases/mean_std_column.ipynb", "completion": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)", "full_response": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)"}
{"task_id": "../test_cases/measure_aspect_ratio_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats"}
{"task_id": "../test_cases/measure_intensity_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]"}
{"task_id": "../test_cases/measure_intensity_over_time.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))", "full_response": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))"}
{"task_id": "../test_cases/measure_mean_image_intensity.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).mean()", "full_response": "\n    import numpy as np\n    return np.asarray(image).mean()"}
{"task_id": "../test_cases/measure_pixel_count_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]"}
{"task_id": "../test_cases/measure_properties_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)"}
{"task_id": "../test_cases/open_image_read_voxel_size.ipynb", "completion": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X", "full_response": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X"}
{"task_id": "../test_cases/open_image_return_dimensions.ipynb", "completion": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape", "full_response": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape"}
{"task_id": "../test_cases/open_nifti_image.ipynb", "completion": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)", "full_response": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)"}
{"task_id": "../test_cases/open_zarr.ipynb", "completion": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array", "full_response": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array"}
{"task_id": "../test_cases/pair_wise_correlation_matrix.ipynb", "completion": "\n    return dataframe.corr()", "full_response": "\n    return dataframe.corr()"}
{"task_id": "../test_cases/radial_intensity_profile.ipynb", "completion": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile ", "full_response": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile "}
{"task_id": "../test_cases/region_growing_segmentation.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.flood(image, point)", "full_response": "\n    import skimage\n    return skimage.segmentation.flood(image, point)"}
{"task_id": "../test_cases/remove_labels_on_edges.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)", "full_response": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)"}
{"task_id": "../test_cases/remove_noise_edge_preserving.ipynb", "completion": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image"}
{"task_id": "../test_cases/remove_small_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)"}
{"task_id": "../test_cases/return_hello_world.ipynb", "completion": "\n    return \"hello world\"", "full_response": "\n    return \"hello world\""}
{"task_id": "../test_cases/rgb_to_grey_image_transform.ipynb", "completion": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image", "full_response": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image"}
{"task_id": "../test_cases/rotate_image_by_90_degrees.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)"}
{"task_id": "../test_cases/subsample_image.ipynb", "completion": "\n    return image[::n,::n]", "full_response": "\n    return image[::n,::n]"}
{"task_id": "../test_cases/subtract_background_tophat.ipynb", "completion": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image", "full_response": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image"}
{"task_id": "../test_cases/sum_images.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)", "full_response": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)"}
{"task_id": "../test_cases/sum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)"}
{"task_id": "../test_cases/tiled_image_processing.ipynb", "completion": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result", "full_response": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result"}
{"task_id": "../test_cases/transpose_image_axes.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).T", "full_response": "\n    import numpy as np\n    return np.asarray(image).T"}
{"task_id": "../test_cases/t_test.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    ", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    "}
{"task_id": "../test_cases/workflow_batch_process_folder_count_labels.ipynb", "completion": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result", "full_response": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result"}
{"task_id": "../test_cases/workflow_batch_process_folder_measure_intensity.ipynb", "completion": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)", "full_response": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)"}
{"task_id": "../test_cases/workflow_segmentation_counting.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()", "full_response": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()"}
{"task_id": "../test_cases/workflow_segmentation_measurement_summary.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)"}
{"task_id": "../test_cases/workflow_segment_measure_umap.ipynb", "completion": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe", "full_response": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe"}
{"task_id": "../test_cases/workflow_watershed_segmentation_correction_measurement.ipynb", "completion": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()", "full_response": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()"}
{"task_id": "../test_cases/apply_otsu_threshold_and_count_postiive_pixels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result"}
{"task_id": "../test_cases/binary_closing.ipynb", "completion": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))", "full_response": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))"}
{"task_id": "../test_cases/binary_skeleton.ipynb", "completion": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)", "full_response": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)"}
{"task_id": "../test_cases/bland_altman.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe"}
{"task_id": "../test_cases/combine_columns_of_tables.ipynb", "completion": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')", "full_response": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')"}
{"task_id": "../test_cases/convex_hull_measure_area.ipynb", "completion": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()", "full_response": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()"}
{"task_id": "../test_cases/convolve_images.ipynb", "completion": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    ", "full_response": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    "}
{"task_id": "../test_cases/count_number_of_touching_neighbors.ipynb", "completion": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]", "full_response": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]"}
{"task_id": "../test_cases/count_objects_over_time.ipynb", "completion": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]", "full_response": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]"}
{"task_id": "../test_cases/count_overlapping_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()"}
{"task_id": "../test_cases/create_umap.ipynb", "completion": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value", "full_response": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value"}
{"task_id": "../test_cases/crop_quarter_image.ipynb", "completion": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]", "full_response": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]"}
{"task_id": "../test_cases/deconvolve_image.ipynb", "completion": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    ", "full_response": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    "}
{"task_id": "../test_cases/detect_edges.ipynb", "completion": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image"}
{"task_id": "../test_cases/expand_labels_without_overlap.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)", "full_response": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)"}
{"task_id": "../test_cases/extract_surface_measure_area.ipynb", "completion": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()", "full_response": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()"}
{"task_id": "../test_cases/fit_circle.ipynb", "completion": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r", "full_response": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r"}
{"task_id": "../test_cases/label_binary_image_and_count_labels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1", "full_response": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1"}
{"task_id": "../test_cases/label_sequentially.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]", "full_response": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]"}
{"task_id": "../test_cases/list_image_files_in_folder.ipynb", "completion": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]", "full_response": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]"}
{"task_id": "../test_cases/map_pixel_count_of_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)"}
{"task_id": "../test_cases/mask_image.ipynb", "completion": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask", "full_response": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask"}
{"task_id": "../test_cases/maximum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)"}
{"task_id": "../test_cases/mean_squared_error.ipynb", "completion": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy", "full_response": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy"}
{"task_id": "../test_cases/mean_std_column.ipynb", "completion": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)", "full_response": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)"}
{"task_id": "../test_cases/measure_aspect_ratio_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats"}
{"task_id": "../test_cases/measure_intensity_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]"}
{"task_id": "../test_cases/measure_intensity_over_time.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))", "full_response": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))"}
{"task_id": "../test_cases/measure_mean_image_intensity.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).mean()", "full_response": "\n    import numpy as np\n    return np.asarray(image).mean()"}
{"task_id": "../test_cases/measure_pixel_count_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]"}
{"task_id": "../test_cases/measure_properties_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)"}
{"task_id": "../test_cases/open_image_read_voxel_size.ipynb", "completion": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X", "full_response": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X"}
{"task_id": "../test_cases/open_image_return_dimensions.ipynb", "completion": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape", "full_response": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape"}
{"task_id": "../test_cases/open_nifti_image.ipynb", "completion": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)", "full_response": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)"}
{"task_id": "../test_cases/open_zarr.ipynb", "completion": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array", "full_response": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array"}
{"task_id": "../test_cases/pair_wise_correlation_matrix.ipynb", "completion": "\n    return dataframe.corr()", "full_response": "\n    return dataframe.corr()"}
{"task_id": "../test_cases/radial_intensity_profile.ipynb", "completion": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile ", "full_response": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile "}
{"task_id": "../test_cases/region_growing_segmentation.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.flood(image, point)", "full_response": "\n    import skimage\n    return skimage.segmentation.flood(image, point)"}
{"task_id": "../test_cases/remove_labels_on_edges.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)", "full_response": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)"}
{"task_id": "../test_cases/remove_noise_edge_preserving.ipynb", "completion": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image"}
{"task_id": "../test_cases/remove_small_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)"}
{"task_id": "../test_cases/return_hello_world.ipynb", "completion": "\n    return \"hello world\"", "full_response": "\n    return \"hello world\""}
{"task_id": "../test_cases/rgb_to_grey_image_transform.ipynb", "completion": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image", "full_response": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image"}
{"task_id": "../test_cases/rotate_image_by_90_degrees.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)"}
{"task_id": "../test_cases/subsample_image.ipynb", "completion": "\n    return image[::n,::n]", "full_response": "\n    return image[::n,::n]"}
{"task_id": "../test_cases/subtract_background_tophat.ipynb", "completion": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image", "full_response": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image"}
{"task_id": "../test_cases/sum_images.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)", "full_response": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)"}
{"task_id": "../test_cases/sum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)"}
{"task_id": "../test_cases/tiled_image_processing.ipynb", "completion": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result", "full_response": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result"}
{"task_id": "../test_cases/transpose_image_axes.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).T", "full_response": "\n    import numpy as np\n    return np.asarray(image).T"}
{"task_id": "../test_cases/t_test.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    ", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    "}
{"task_id": "../test_cases/workflow_batch_process_folder_count_labels.ipynb", "completion": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result", "full_response": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result"}
{"task_id": "../test_cases/workflow_batch_process_folder_measure_intensity.ipynb", "completion": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)", "full_response": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)"}
{"task_id": "../test_cases/workflow_segmentation_counting.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()", "full_response": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()"}
{"task_id": "../test_cases/workflow_segmentation_measurement_summary.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)"}
{"task_id": "../test_cases/workflow_segment_measure_umap.ipynb", "completion": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe", "full_response": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe"}
{"task_id": "../test_cases/workflow_watershed_segmentation_correction_measurement.ipynb", "completion": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()", "full_response": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()"}
{"task_id": "../test_cases/apply_otsu_threshold_and_count_postiive_pixels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result"}
{"task_id": "../test_cases/binary_closing.ipynb", "completion": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))", "full_response": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))"}
{"task_id": "../test_cases/binary_skeleton.ipynb", "completion": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)", "full_response": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)"}
{"task_id": "../test_cases/bland_altman.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe"}
{"task_id": "../test_cases/combine_columns_of_tables.ipynb", "completion": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')", "full_response": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')"}
{"task_id": "../test_cases/convex_hull_measure_area.ipynb", "completion": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()", "full_response": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()"}
{"task_id": "../test_cases/convolve_images.ipynb", "completion": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    ", "full_response": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    "}
{"task_id": "../test_cases/count_number_of_touching_neighbors.ipynb", "completion": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]", "full_response": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]"}
{"task_id": "../test_cases/count_objects_over_time.ipynb", "completion": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]", "full_response": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]"}
{"task_id": "../test_cases/count_overlapping_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()"}
{"task_id": "../test_cases/create_umap.ipynb", "completion": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value", "full_response": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value"}
{"task_id": "../test_cases/crop_quarter_image.ipynb", "completion": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]", "full_response": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]"}
{"task_id": "../test_cases/deconvolve_image.ipynb", "completion": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    ", "full_response": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    "}
{"task_id": "../test_cases/detect_edges.ipynb", "completion": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image"}
{"task_id": "../test_cases/expand_labels_without_overlap.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)", "full_response": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)"}
{"task_id": "../test_cases/extract_surface_measure_area.ipynb", "completion": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()", "full_response": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()"}
{"task_id": "../test_cases/fit_circle.ipynb", "completion": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r", "full_response": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r"}
{"task_id": "../test_cases/label_binary_image_and_count_labels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1", "full_response": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1"}
{"task_id": "../test_cases/label_sequentially.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]", "full_response": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]"}
{"task_id": "../test_cases/list_image_files_in_folder.ipynb", "completion": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]", "full_response": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]"}
{"task_id": "../test_cases/map_pixel_count_of_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)"}
{"task_id": "../test_cases/mask_image.ipynb", "completion": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask", "full_response": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask"}
{"task_id": "../test_cases/maximum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)"}
{"task_id": "../test_cases/mean_squared_error.ipynb", "completion": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy", "full_response": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy"}
{"task_id": "../test_cases/mean_std_column.ipynb", "completion": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)", "full_response": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)"}
{"task_id": "../test_cases/measure_aspect_ratio_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats"}
{"task_id": "../test_cases/measure_intensity_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]"}
{"task_id": "../test_cases/measure_intensity_over_time.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))", "full_response": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))"}
{"task_id": "../test_cases/measure_mean_image_intensity.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).mean()", "full_response": "\n    import numpy as np\n    return np.asarray(image).mean()"}
{"task_id": "../test_cases/measure_pixel_count_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]"}
{"task_id": "../test_cases/measure_properties_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)"}
{"task_id": "../test_cases/open_image_read_voxel_size.ipynb", "completion": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X", "full_response": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X"}
{"task_id": "../test_cases/open_image_return_dimensions.ipynb", "completion": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape", "full_response": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape"}
{"task_id": "../test_cases/open_nifti_image.ipynb", "completion": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)", "full_response": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)"}
{"task_id": "../test_cases/open_zarr.ipynb", "completion": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array", "full_response": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array"}
{"task_id": "../test_cases/pair_wise_correlation_matrix.ipynb", "completion": "\n    return dataframe.corr()", "full_response": "\n    return dataframe.corr()"}
{"task_id": "../test_cases/radial_intensity_profile.ipynb", "completion": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile ", "full_response": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile "}
{"task_id": "../test_cases/region_growing_segmentation.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.flood(image, point)", "full_response": "\n    import skimage\n    return skimage.segmentation.flood(image, point)"}
{"task_id": "../test_cases/remove_labels_on_edges.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)", "full_response": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)"}
{"task_id": "../test_cases/remove_noise_edge_preserving.ipynb", "completion": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image"}
{"task_id": "../test_cases/remove_small_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)"}
{"task_id": "../test_cases/return_hello_world.ipynb", "completion": "\n    return \"hello world\"", "full_response": "\n    return \"hello world\""}
{"task_id": "../test_cases/rgb_to_grey_image_transform.ipynb", "completion": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image", "full_response": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image"}
{"task_id": "../test_cases/rotate_image_by_90_degrees.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)"}
{"task_id": "../test_cases/subsample_image.ipynb", "completion": "\n    return image[::n,::n]", "full_response": "\n    return image[::n,::n]"}
{"task_id": "../test_cases/subtract_background_tophat.ipynb", "completion": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image", "full_response": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image"}
{"task_id": "../test_cases/sum_images.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)", "full_response": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)"}
{"task_id": "../test_cases/sum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)"}
{"task_id": "../test_cases/tiled_image_processing.ipynb", "completion": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result", "full_response": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result"}
{"task_id": "../test_cases/transpose_image_axes.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).T", "full_response": "\n    import numpy as np\n    return np.asarray(image).T"}
{"task_id": "../test_cases/t_test.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    ", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    "}
{"task_id": "../test_cases/workflow_batch_process_folder_count_labels.ipynb", "completion": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result", "full_response": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result"}
{"task_id": "../test_cases/workflow_batch_process_folder_measure_intensity.ipynb", "completion": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)", "full_response": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)"}
{"task_id": "../test_cases/workflow_segmentation_counting.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()", "full_response": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()"}
{"task_id": "../test_cases/workflow_segmentation_measurement_summary.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)"}
{"task_id": "../test_cases/workflow_segment_measure_umap.ipynb", "completion": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe", "full_response": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe"}
{"task_id": "../test_cases/workflow_watershed_segmentation_correction_measurement.ipynb", "completion": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()", "full_response": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()"}
{"task_id": "../test_cases/apply_otsu_threshold_and_count_postiive_pixels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result"}
{"task_id": "../test_cases/binary_closing.ipynb", "completion": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))", "full_response": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))"}
{"task_id": "../test_cases/binary_skeleton.ipynb", "completion": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)", "full_response": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)"}
{"task_id": "../test_cases/bland_altman.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe"}
{"task_id": "../test_cases/combine_columns_of_tables.ipynb", "completion": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')", "full_response": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')"}
{"task_id": "../test_cases/convex_hull_measure_area.ipynb", "completion": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()", "full_response": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()"}
{"task_id": "../test_cases/convolve_images.ipynb", "completion": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    ", "full_response": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    "}
{"task_id": "../test_cases/count_number_of_touching_neighbors.ipynb", "completion": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]", "full_response": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]"}
{"task_id": "../test_cases/count_objects_over_time.ipynb", "completion": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]", "full_response": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]"}
{"task_id": "../test_cases/count_overlapping_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()"}
{"task_id": "../test_cases/create_umap.ipynb", "completion": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value", "full_response": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value"}
{"task_id": "../test_cases/crop_quarter_image.ipynb", "completion": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]", "full_response": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]"}
{"task_id": "../test_cases/deconvolve_image.ipynb", "completion": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    ", "full_response": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    "}
{"task_id": "../test_cases/detect_edges.ipynb", "completion": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image"}
{"task_id": "../test_cases/expand_labels_without_overlap.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)", "full_response": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)"}
{"task_id": "../test_cases/extract_surface_measure_area.ipynb", "completion": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()", "full_response": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()"}
{"task_id": "../test_cases/fit_circle.ipynb", "completion": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r", "full_response": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r"}
{"task_id": "../test_cases/label_binary_image_and_count_labels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1", "full_response": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1"}
{"task_id": "../test_cases/label_sequentially.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]", "full_response": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]"}
{"task_id": "../test_cases/list_image_files_in_folder.ipynb", "completion": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]", "full_response": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]"}
{"task_id": "../test_cases/map_pixel_count_of_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)"}
{"task_id": "../test_cases/mask_image.ipynb", "completion": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask", "full_response": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask"}
{"task_id": "../test_cases/maximum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)"}
{"task_id": "../test_cases/mean_squared_error.ipynb", "completion": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy", "full_response": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy"}
{"task_id": "../test_cases/mean_std_column.ipynb", "completion": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)", "full_response": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)"}
{"task_id": "../test_cases/measure_aspect_ratio_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats"}
{"task_id": "../test_cases/measure_intensity_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]"}
{"task_id": "../test_cases/measure_intensity_over_time.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))", "full_response": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))"}
{"task_id": "../test_cases/measure_mean_image_intensity.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).mean()", "full_response": "\n    import numpy as np\n    return np.asarray(image).mean()"}
{"task_id": "../test_cases/measure_pixel_count_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]"}
{"task_id": "../test_cases/measure_properties_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)"}
{"task_id": "../test_cases/open_image_read_voxel_size.ipynb", "completion": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X", "full_response": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X"}
{"task_id": "../test_cases/open_image_return_dimensions.ipynb", "completion": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape", "full_response": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape"}
{"task_id": "../test_cases/open_nifti_image.ipynb", "completion": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)", "full_response": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)"}
{"task_id": "../test_cases/open_zarr.ipynb", "completion": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array", "full_response": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array"}
{"task_id": "../test_cases/pair_wise_correlation_matrix.ipynb", "completion": "\n    return dataframe.corr()", "full_response": "\n    return dataframe.corr()"}
{"task_id": "../test_cases/radial_intensity_profile.ipynb", "completion": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile ", "full_response": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile "}
{"task_id": "../test_cases/region_growing_segmentation.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.flood(image, point)", "full_response": "\n    import skimage\n    return skimage.segmentation.flood(image, point)"}
{"task_id": "../test_cases/remove_labels_on_edges.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)", "full_response": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)"}
{"task_id": "../test_cases/remove_noise_edge_preserving.ipynb", "completion": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image"}
{"task_id": "../test_cases/remove_small_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)"}
{"task_id": "../test_cases/return_hello_world.ipynb", "completion": "\n    return \"hello world\"", "full_response": "\n    return \"hello world\""}
{"task_id": "../test_cases/rgb_to_grey_image_transform.ipynb", "completion": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image", "full_response": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image"}
{"task_id": "../test_cases/rotate_image_by_90_degrees.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)"}
{"task_id": "../test_cases/subsample_image.ipynb", "completion": "\n    return image[::n,::n]", "full_response": "\n    return image[::n,::n]"}
{"task_id": "../test_cases/subtract_background_tophat.ipynb", "completion": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image", "full_response": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image"}
{"task_id": "../test_cases/sum_images.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)", "full_response": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)"}
{"task_id": "../test_cases/sum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)"}
{"task_id": "../test_cases/tiled_image_processing.ipynb", "completion": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result", "full_response": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result"}
{"task_id": "../test_cases/transpose_image_axes.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).T", "full_response": "\n    import numpy as np\n    return np.asarray(image).T"}
{"task_id": "../test_cases/t_test.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    ", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    "}
{"task_id": "../test_cases/workflow_batch_process_folder_count_labels.ipynb", "completion": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result", "full_response": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result"}
{"task_id": "../test_cases/workflow_batch_process_folder_measure_intensity.ipynb", "completion": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)", "full_response": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)"}
{"task_id": "../test_cases/workflow_segmentation_counting.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()", "full_response": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()"}
{"task_id": "../test_cases/workflow_segmentation_measurement_summary.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)"}
{"task_id": "../test_cases/workflow_segment_measure_umap.ipynb", "completion": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe", "full_response": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe"}
{"task_id": "../test_cases/workflow_watershed_segmentation_correction_measurement.ipynb", "completion": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()", "full_response": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()"}
{"task_id": "../test_cases/apply_otsu_threshold_and_count_postiive_pixels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result"}
{"task_id": "../test_cases/binary_closing.ipynb", "completion": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))", "full_response": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))"}
{"task_id": "../test_cases/binary_skeleton.ipynb", "completion": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)", "full_response": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)"}
{"task_id": "../test_cases/bland_altman.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe"}
{"task_id": "../test_cases/combine_columns_of_tables.ipynb", "completion": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')", "full_response": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')"}
{"task_id": "../test_cases/convex_hull_measure_area.ipynb", "completion": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()", "full_response": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()"}
{"task_id": "../test_cases/convolve_images.ipynb", "completion": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    ", "full_response": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    "}
{"task_id": "../test_cases/count_number_of_touching_neighbors.ipynb", "completion": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]", "full_response": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]"}
{"task_id": "../test_cases/count_objects_over_time.ipynb", "completion": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]", "full_response": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]"}
{"task_id": "../test_cases/count_overlapping_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()"}
{"task_id": "../test_cases/create_umap.ipynb", "completion": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value", "full_response": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value"}
{"task_id": "../test_cases/crop_quarter_image.ipynb", "completion": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]", "full_response": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]"}
{"task_id": "../test_cases/deconvolve_image.ipynb", "completion": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    ", "full_response": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    "}
{"task_id": "../test_cases/detect_edges.ipynb", "completion": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image"}
{"task_id": "../test_cases/expand_labels_without_overlap.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)", "full_response": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)"}
{"task_id": "../test_cases/extract_surface_measure_area.ipynb", "completion": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()", "full_response": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()"}
{"task_id": "../test_cases/fit_circle.ipynb", "completion": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r", "full_response": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r"}
{"task_id": "../test_cases/label_binary_image_and_count_labels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1", "full_response": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1"}
{"task_id": "../test_cases/label_sequentially.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]", "full_response": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]"}
{"task_id": "../test_cases/list_image_files_in_folder.ipynb", "completion": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]", "full_response": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]"}
{"task_id": "../test_cases/map_pixel_count_of_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)"}
{"task_id": "../test_cases/mask_image.ipynb", "completion": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask", "full_response": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask"}
{"task_id": "../test_cases/maximum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)"}
{"task_id": "../test_cases/mean_squared_error.ipynb", "completion": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy", "full_response": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy"}
{"task_id": "../test_cases/mean_std_column.ipynb", "completion": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)", "full_response": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)"}
{"task_id": "../test_cases/measure_aspect_ratio_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats"}
{"task_id": "../test_cases/measure_intensity_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]"}
{"task_id": "../test_cases/measure_intensity_over_time.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))", "full_response": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))"}
{"task_id": "../test_cases/measure_mean_image_intensity.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).mean()", "full_response": "\n    import numpy as np\n    return np.asarray(image).mean()"}
{"task_id": "../test_cases/measure_pixel_count_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]"}
{"task_id": "../test_cases/measure_properties_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)"}
{"task_id": "../test_cases/open_image_read_voxel_size.ipynb", "completion": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X", "full_response": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X"}
{"task_id": "../test_cases/open_image_return_dimensions.ipynb", "completion": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape", "full_response": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape"}
{"task_id": "../test_cases/open_nifti_image.ipynb", "completion": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)", "full_response": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)"}
{"task_id": "../test_cases/open_zarr.ipynb", "completion": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array", "full_response": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array"}
{"task_id": "../test_cases/pair_wise_correlation_matrix.ipynb", "completion": "\n    return dataframe.corr()", "full_response": "\n    return dataframe.corr()"}
{"task_id": "../test_cases/radial_intensity_profile.ipynb", "completion": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile ", "full_response": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile "}
{"task_id": "../test_cases/region_growing_segmentation.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.flood(image, point)", "full_response": "\n    import skimage\n    return skimage.segmentation.flood(image, point)"}
{"task_id": "../test_cases/remove_labels_on_edges.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)", "full_response": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)"}
{"task_id": "../test_cases/remove_noise_edge_preserving.ipynb", "completion": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image"}
{"task_id": "../test_cases/remove_small_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)"}
{"task_id": "../test_cases/return_hello_world.ipynb", "completion": "\n    return \"hello world\"", "full_response": "\n    return \"hello world\""}
{"task_id": "../test_cases/rgb_to_grey_image_transform.ipynb", "completion": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image", "full_response": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image"}
{"task_id": "../test_cases/rotate_image_by_90_degrees.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)"}
{"task_id": "../test_cases/subsample_image.ipynb", "completion": "\n    return image[::n,::n]", "full_response": "\n    return image[::n,::n]"}
{"task_id": "../test_cases/subtract_background_tophat.ipynb", "completion": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image", "full_response": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image"}
{"task_id": "../test_cases/sum_images.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)", "full_response": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)"}
{"task_id": "../test_cases/sum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)"}
{"task_id": "../test_cases/tiled_image_processing.ipynb", "completion": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result", "full_response": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result"}
{"task_id": "../test_cases/transpose_image_axes.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).T", "full_response": "\n    import numpy as np\n    return np.asarray(image).T"}
{"task_id": "../test_cases/t_test.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    ", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    "}
{"task_id": "../test_cases/workflow_batch_process_folder_count_labels.ipynb", "completion": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result", "full_response": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result"}
{"task_id": "../test_cases/workflow_batch_process_folder_measure_intensity.ipynb", "completion": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)", "full_response": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)"}
{"task_id": "../test_cases/workflow_segmentation_counting.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()", "full_response": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()"}
{"task_id": "../test_cases/workflow_segmentation_measurement_summary.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)"}
{"task_id": "../test_cases/workflow_segment_measure_umap.ipynb", "completion": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe", "full_response": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe"}
{"task_id": "../test_cases/workflow_watershed_segmentation_correction_measurement.ipynb", "completion": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()", "full_response": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()"}
{"task_id": "../test_cases/apply_otsu_threshold_and_count_postiive_pixels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result"}
{"task_id": "../test_cases/binary_closing.ipynb", "completion": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))", "full_response": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))"}
{"task_id": "../test_cases/binary_skeleton.ipynb", "completion": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)", "full_response": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)"}
{"task_id": "../test_cases/bland_altman.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe"}
{"task_id": "../test_cases/combine_columns_of_tables.ipynb", "completion": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')", "full_response": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')"}
{"task_id": "../test_cases/convex_hull_measure_area.ipynb", "completion": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()", "full_response": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()"}
{"task_id": "../test_cases/convolve_images.ipynb", "completion": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    ", "full_response": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    "}
{"task_id": "../test_cases/count_number_of_touching_neighbors.ipynb", "completion": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]", "full_response": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]"}
{"task_id": "../test_cases/count_objects_over_time.ipynb", "completion": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]", "full_response": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]"}
{"task_id": "../test_cases/count_overlapping_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()"}
{"task_id": "../test_cases/create_umap.ipynb", "completion": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value", "full_response": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value"}
{"task_id": "../test_cases/crop_quarter_image.ipynb", "completion": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]", "full_response": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]"}
{"task_id": "../test_cases/deconvolve_image.ipynb", "completion": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    ", "full_response": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    "}
{"task_id": "../test_cases/detect_edges.ipynb", "completion": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image"}
{"task_id": "../test_cases/expand_labels_without_overlap.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)", "full_response": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)"}
{"task_id": "../test_cases/extract_surface_measure_area.ipynb", "completion": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()", "full_response": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()"}
{"task_id": "../test_cases/fit_circle.ipynb", "completion": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r", "full_response": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r"}
{"task_id": "../test_cases/label_binary_image_and_count_labels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1", "full_response": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1"}
{"task_id": "../test_cases/label_sequentially.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]", "full_response": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]"}
{"task_id": "../test_cases/list_image_files_in_folder.ipynb", "completion": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]", "full_response": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]"}
{"task_id": "../test_cases/map_pixel_count_of_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)"}
{"task_id": "../test_cases/mask_image.ipynb", "completion": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask", "full_response": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask"}
{"task_id": "../test_cases/maximum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)"}
{"task_id": "../test_cases/mean_squared_error.ipynb", "completion": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy", "full_response": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy"}
{"task_id": "../test_cases/mean_std_column.ipynb", "completion": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)", "full_response": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)"}
{"task_id": "../test_cases/measure_aspect_ratio_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats"}
{"task_id": "../test_cases/measure_intensity_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]"}
{"task_id": "../test_cases/measure_intensity_over_time.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))", "full_response": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))"}
{"task_id": "../test_cases/measure_mean_image_intensity.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).mean()", "full_response": "\n    import numpy as np\n    return np.asarray(image).mean()"}
{"task_id": "../test_cases/measure_pixel_count_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]"}
{"task_id": "../test_cases/measure_properties_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)"}
{"task_id": "../test_cases/open_image_read_voxel_size.ipynb", "completion": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X", "full_response": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X"}
{"task_id": "../test_cases/open_image_return_dimensions.ipynb", "completion": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape", "full_response": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape"}
{"task_id": "../test_cases/open_nifti_image.ipynb", "completion": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)", "full_response": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)"}
{"task_id": "../test_cases/open_zarr.ipynb", "completion": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array", "full_response": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array"}
{"task_id": "../test_cases/pair_wise_correlation_matrix.ipynb", "completion": "\n    return dataframe.corr()", "full_response": "\n    return dataframe.corr()"}
{"task_id": "../test_cases/radial_intensity_profile.ipynb", "completion": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile ", "full_response": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile "}
{"task_id": "../test_cases/region_growing_segmentation.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.flood(image, point)", "full_response": "\n    import skimage\n    return skimage.segmentation.flood(image, point)"}
{"task_id": "../test_cases/remove_labels_on_edges.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)", "full_response": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)"}
{"task_id": "../test_cases/remove_noise_edge_preserving.ipynb", "completion": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image"}
{"task_id": "../test_cases/remove_small_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)"}
{"task_id": "../test_cases/return_hello_world.ipynb", "completion": "\n    return \"hello world\"", "full_response": "\n    return \"hello world\""}
{"task_id": "../test_cases/rgb_to_grey_image_transform.ipynb", "completion": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image", "full_response": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image"}
{"task_id": "../test_cases/rotate_image_by_90_degrees.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)"}
{"task_id": "../test_cases/subsample_image.ipynb", "completion": "\n    return image[::n,::n]", "full_response": "\n    return image[::n,::n]"}
{"task_id": "../test_cases/subtract_background_tophat.ipynb", "completion": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image", "full_response": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image"}
{"task_id": "../test_cases/sum_images.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)", "full_response": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)"}
{"task_id": "../test_cases/sum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)"}
{"task_id": "../test_cases/tiled_image_processing.ipynb", "completion": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result", "full_response": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result"}
{"task_id": "../test_cases/transpose_image_axes.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).T", "full_response": "\n    import numpy as np\n    return np.asarray(image).T"}
{"task_id": "../test_cases/t_test.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    ", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    "}
{"task_id": "../test_cases/workflow_batch_process_folder_count_labels.ipynb", "completion": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result", "full_response": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result"}
{"task_id": "../test_cases/workflow_batch_process_folder_measure_intensity.ipynb", "completion": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)", "full_response": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)"}
{"task_id": "../test_cases/workflow_segmentation_counting.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()", "full_response": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()"}
{"task_id": "../test_cases/workflow_segmentation_measurement_summary.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)"}
{"task_id": "../test_cases/workflow_segment_measure_umap.ipynb", "completion": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe", "full_response": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe"}
{"task_id": "../test_cases/workflow_watershed_segmentation_correction_measurement.ipynb", "completion": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()", "full_response": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()"}
{"task_id": "../test_cases/apply_otsu_threshold_and_count_postiive_pixels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result"}
{"task_id": "../test_cases/binary_closing.ipynb", "completion": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))", "full_response": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))"}
{"task_id": "../test_cases/binary_skeleton.ipynb", "completion": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)", "full_response": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)"}
{"task_id": "../test_cases/bland_altman.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe"}
{"task_id": "../test_cases/combine_columns_of_tables.ipynb", "completion": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')", "full_response": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')"}
{"task_id": "../test_cases/convex_hull_measure_area.ipynb", "completion": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()", "full_response": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()"}
{"task_id": "../test_cases/convolve_images.ipynb", "completion": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    ", "full_response": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    "}
{"task_id": "../test_cases/count_number_of_touching_neighbors.ipynb", "completion": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]", "full_response": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]"}
{"task_id": "../test_cases/count_objects_over_time.ipynb", "completion": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]", "full_response": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]"}
{"task_id": "../test_cases/count_overlapping_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()"}
{"task_id": "../test_cases/create_umap.ipynb", "completion": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value", "full_response": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value"}
{"task_id": "../test_cases/crop_quarter_image.ipynb", "completion": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]", "full_response": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]"}
{"task_id": "../test_cases/deconvolve_image.ipynb", "completion": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    ", "full_response": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    "}
{"task_id": "../test_cases/detect_edges.ipynb", "completion": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image"}
{"task_id": "../test_cases/expand_labels_without_overlap.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)", "full_response": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)"}
{"task_id": "../test_cases/extract_surface_measure_area.ipynb", "completion": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()", "full_response": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()"}
{"task_id": "../test_cases/fit_circle.ipynb", "completion": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r", "full_response": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r"}
{"task_id": "../test_cases/label_binary_image_and_count_labels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1", "full_response": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1"}
{"task_id": "../test_cases/label_sequentially.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]", "full_response": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]"}
{"task_id": "../test_cases/list_image_files_in_folder.ipynb", "completion": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]", "full_response": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]"}
{"task_id": "../test_cases/map_pixel_count_of_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)"}
{"task_id": "../test_cases/mask_image.ipynb", "completion": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask", "full_response": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask"}
{"task_id": "../test_cases/maximum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)"}
{"task_id": "../test_cases/mean_squared_error.ipynb", "completion": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy", "full_response": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy"}
{"task_id": "../test_cases/mean_std_column.ipynb", "completion": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)", "full_response": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)"}
{"task_id": "../test_cases/measure_aspect_ratio_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats"}
{"task_id": "../test_cases/measure_intensity_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]"}
{"task_id": "../test_cases/measure_intensity_over_time.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))", "full_response": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))"}
{"task_id": "../test_cases/measure_mean_image_intensity.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).mean()", "full_response": "\n    import numpy as np\n    return np.asarray(image).mean()"}
{"task_id": "../test_cases/measure_pixel_count_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]"}
{"task_id": "../test_cases/measure_properties_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)"}
{"task_id": "../test_cases/open_image_read_voxel_size.ipynb", "completion": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X", "full_response": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X"}
{"task_id": "../test_cases/open_image_return_dimensions.ipynb", "completion": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape", "full_response": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape"}
{"task_id": "../test_cases/open_nifti_image.ipynb", "completion": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)", "full_response": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)"}
{"task_id": "../test_cases/open_zarr.ipynb", "completion": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array", "full_response": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array"}
{"task_id": "../test_cases/pair_wise_correlation_matrix.ipynb", "completion": "\n    return dataframe.corr()", "full_response": "\n    return dataframe.corr()"}
{"task_id": "../test_cases/radial_intensity_profile.ipynb", "completion": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile ", "full_response": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile "}
{"task_id": "../test_cases/region_growing_segmentation.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.flood(image, point)", "full_response": "\n    import skimage\n    return skimage.segmentation.flood(image, point)"}
{"task_id": "../test_cases/remove_labels_on_edges.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)", "full_response": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)"}
{"task_id": "../test_cases/remove_noise_edge_preserving.ipynb", "completion": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image"}
{"task_id": "../test_cases/remove_small_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)"}
{"task_id": "../test_cases/return_hello_world.ipynb", "completion": "\n    return \"hello world\"", "full_response": "\n    return \"hello world\""}
{"task_id": "../test_cases/rgb_to_grey_image_transform.ipynb", "completion": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image", "full_response": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image"}
{"task_id": "../test_cases/rotate_image_by_90_degrees.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)"}
{"task_id": "../test_cases/subsample_image.ipynb", "completion": "\n    return image[::n,::n]", "full_response": "\n    return image[::n,::n]"}
{"task_id": "../test_cases/subtract_background_tophat.ipynb", "completion": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image", "full_response": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image"}
{"task_id": "../test_cases/sum_images.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)", "full_response": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)"}
{"task_id": "../test_cases/sum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)"}
{"task_id": "../test_cases/tiled_image_processing.ipynb", "completion": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result", "full_response": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result"}
{"task_id": "../test_cases/transpose_image_axes.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).T", "full_response": "\n    import numpy as np\n    return np.asarray(image).T"}
{"task_id": "../test_cases/t_test.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    ", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    "}
{"task_id": "../test_cases/workflow_batch_process_folder_count_labels.ipynb", "completion": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result", "full_response": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result"}
{"task_id": "../test_cases/workflow_batch_process_folder_measure_intensity.ipynb", "completion": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)", "full_response": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)"}
{"task_id": "../test_cases/workflow_segmentation_counting.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()", "full_response": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()"}
{"task_id": "../test_cases/workflow_segmentation_measurement_summary.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)"}
{"task_id": "../test_cases/workflow_segment_measure_umap.ipynb", "completion": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe", "full_response": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe"}
{"task_id": "../test_cases/workflow_watershed_segmentation_correction_measurement.ipynb", "completion": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()", "full_response": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()"}
{"task_id": "../test_cases/apply_otsu_threshold_and_count_postiive_pixels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n\n    result = np.sum(binary_image)\n\n    return result"}
{"task_id": "../test_cases/binary_closing.ipynb", "completion": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))", "full_response": "\n    import numpy as np\n    import skimage\n    size = radius * 2 + 1\n    return skimage.morphology.binary_closing(binary_image, footprint=np.ones((size, size)))"}
{"task_id": "../test_cases/binary_skeleton.ipynb", "completion": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)", "full_response": "\n    from skimage.morphology import skeletonize\n    return skeletonize(binary_image)"}
{"task_id": "../test_cases/bland_altman.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    dataframe['mean'] = (data1 + data2) / 2\n    dataframe['diff'] = data2 - data1\n    return dataframe"}
{"task_id": "../test_cases/combine_columns_of_tables.ipynb", "completion": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')", "full_response": "\n    import pandas as pd\n    return pd.merge(dataframe1, dataframe2, how='outer', on='label')"}
{"task_id": "../test_cases/convex_hull_measure_area.ipynb", "completion": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()", "full_response": "\n    import vedo\n    convex_hull = vedo.shapes.ConvexHull(point_cloud)\n    return convex_hull.area()"}
{"task_id": "../test_cases/convolve_images.ipynb", "completion": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    ", "full_response": "\n    import scipy\n    return scipy.ndimage.convolve(image, kernel_image)\n    "}
{"task_id": "../test_cases/count_number_of_touching_neighbors.ipynb", "completion": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]", "full_response": "\n    import numpy as np\n    import pyclesperanto_prototype as cle\n\n    touch_matrix = cle.generate_touch_matrix(label_image)\n    cle.set_row(touch_matrix, 0, 0)\n    cle.set_column(touch_matrix, 0, 0)\n\n    return np.asarray(cle.sum_y_projection(touch_matrix))[0,1:]"}
{"task_id": "../test_cases/count_objects_over_time.ipynb", "completion": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]", "full_response": "\n    import numpy as np\n    from skimage.measure import label\n    labels = [label(binary_image) for binary_image in binary_image_list]\n    return [len(np.unique(label)) - 1 for label in labels]"}
{"task_id": "../test_cases/count_overlapping_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image_1, label_image_2, properties=('mean_intensity',))\n    return (pd.DataFrame(stats)['mean_intensity'] > 0).sum()"}
{"task_id": "../test_cases/create_umap.ipynb", "completion": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value", "full_response": "\n    import umap\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    # no return value"}
{"task_id": "../test_cases/crop_quarter_image.ipynb", "completion": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]", "full_response": "\n    width = image.shape[1]\n    height = image.shape[0]\n\n    return image[:int(width/2),:int(height/2)]"}
{"task_id": "../test_cases/deconvolve_image.ipynb", "completion": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    ", "full_response": "\n    from scipy import fftpack\n\n    # adapted from: https://stackoverflow.com/questions/17473917/is-there-a-equivalent-of-scipy-signal-deconvolve-for-2d-arrays\n    star_fft = fftpack.fftshift(fftpack.fftn(image))\n    psf_fft = fftpack.fftshift(fftpack.fftn(kernel_image))\n    return fftpack.fftshift(fftpack.ifftn(fftpack.ifftshift(star_fft/psf_fft)))\n    "}
{"task_id": "../test_cases/detect_edges.ipynb", "completion": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import sobel\n    filtered_image = sobel(image)\n    return filtered_image"}
{"task_id": "../test_cases/expand_labels_without_overlap.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)", "full_response": "\n    import skimage\n    return skimage.segmentation.expand_labels(label_image, distance=radius)"}
{"task_id": "../test_cases/extract_surface_measure_area.ipynb", "completion": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()", "full_response": "\n    import vedo\n    volume = vedo.Volume(binary_volume_image)\n    iso_surface = volume.isosurface()\n    return iso_surface.area()"}
{"task_id": "../test_cases/fit_circle.ipynb", "completion": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r", "full_response": "\n    import circle_fit as cf\n    xc, yc, r, _ = cf.least_squares_circle(list_of_2d_points)\n    return xc,yc,r"}
{"task_id": "../test_cases/label_binary_image_and_count_labels.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1", "full_response": "\n    import skimage\n    import numpy as np\n    label_image = skimage.measure.label(binary_image)\n\n    return len(np.unique(label_image)) - 1"}
{"task_id": "../test_cases/label_sequentially.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]", "full_response": "\n    import skimage\n    return skimage.segmentation.relabel_sequential(label_image)[0]"}
{"task_id": "../test_cases/list_image_files_in_folder.ipynb", "completion": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]", "full_response": "\n    import os\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    return [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]"}
{"task_id": "../test_cases/map_pixel_count_of_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.pixel_count_map(label_image)"}
{"task_id": "../test_cases/mask_image.ipynb", "completion": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask", "full_response": "\n    import numpy as np\n    image = np.asarray(image)\n    mask = np.asarray(mask)\n    return image * mask"}
{"task_id": "../test_cases/maximum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).max(axis=0)"}
{"task_id": "../test_cases/mean_squared_error.ipynb", "completion": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy", "full_response": "\n    import numpy as np\n    image1 = np.asarray(image1)\n    image2 = np.asarray(image2)\n    return ((image1 - image2)**2).mean()\n    # adapted from : https://stackoverflow.com/questions/16774849/mean-squared-error-in-numpy"}
{"task_id": "../test_cases/mean_std_column.ipynb", "completion": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)", "full_response": "\n    import numpy as np\n    data = dataframe[column]\n    return np.mean(data), np.std(data)"}
{"task_id": "../test_cases/measure_aspect_ratio_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = pd.DataFrame(skimage.measure.regionprops_table(label_image, properties=('minor_axis_length', 'major_axis_length')))\n    stats['aspect_ratio'] = stats['major_axis_length'] / stats['minor_axis_length']\n    return stats"}
{"task_id": "../test_cases/measure_intensity_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image, intensity_image)\n    return [s.mean_intensity for s in stats]"}
{"task_id": "../test_cases/measure_intensity_over_time.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))", "full_response": "\n    import numpy as np\n    return np.asarray(image_list).mean(axis=(1,2))"}
{"task_id": "../test_cases/measure_mean_image_intensity.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).mean()", "full_response": "\n    import numpy as np\n    return np.asarray(image).mean()"}
{"task_id": "../test_cases/measure_pixel_count_of_labels.ipynb", "completion": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]", "full_response": "\n    import skimage\n    stats = skimage.measure.regionprops(label_image)\n    return [s.area for s in stats]"}
{"task_id": "../test_cases/measure_properties_of_regions.ipynb", "completion": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)", "full_response": "\n    import skimage\n    import pandas as pd\n    stats = skimage.measure.regionprops_table(label_image, intensity_image, properties=('area', 'perimeter', 'mean_intensity'))\n    return pd.DataFrame(stats)"}
{"task_id": "../test_cases/open_image_read_voxel_size.ipynb", "completion": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X", "full_response": "\n    from aicsimageio import AICSImage\n    aics_image = AICSImage(image_filename)\n\n    return aics_image.physical_pixel_sizes.Z, \\\n            aics_image.physical_pixel_sizes.Y, \\\n            aics_image.physical_pixel_sizes.X"}
{"task_id": "../test_cases/open_image_return_dimensions.ipynb", "completion": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape", "full_response": "\n    from skimage.io import imread\n    image = imread(image_file_location)\n    return image.shape"}
{"task_id": "../test_cases/open_nifti_image.ipynb", "completion": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)", "full_response": "\n    \n    import nibabel as nib\n    import numpy as nb\n\n    img = nib.load(image_file_location)\n    data = img.get_fdata()\n    return(data)"}
{"task_id": "../test_cases/open_zarr.ipynb", "completion": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array", "full_response": "\n    import zarr\n    array = zarr.load(zarr_file_location)\n    return array"}
{"task_id": "../test_cases/pair_wise_correlation_matrix.ipynb", "completion": "\n    return dataframe.corr()", "full_response": "\n    return dataframe.corr()"}
{"task_id": "../test_cases/radial_intensity_profile.ipynb", "completion": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile ", "full_response": "\n    import numpy as np\n    y, x = np.indices((image.shape))\n    r = np.sqrt((x - xc)**2 + (y - yc)**2)\n    r = r.astype(int)\n    summed_values = np.bincount(r.ravel(), image.ravel())\n    number_of_pixels_at_r = np.bincount(r.ravel())\n    radial_profile = summed_values / number_of_pixels_at_r\n    return radial_profile "}
{"task_id": "../test_cases/region_growing_segmentation.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.flood(image, point)", "full_response": "\n    import skimage\n    return skimage.segmentation.flood(image, point)"}
{"task_id": "../test_cases/remove_labels_on_edges.ipynb", "completion": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)", "full_response": "\n    import skimage\n    return skimage.segmentation.clear_border(label_image)"}
{"task_id": "../test_cases/remove_noise_edge_preserving.ipynb", "completion": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image", "full_response": "\n    from scipy.ndimage import median_filter\n    filtered_image = median_filter(image, size=radius * 2 + 1)\n    return filtered_image"}
{"task_id": "../test_cases/remove_small_labels.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.exclude_small_labels(label_image, maximum_size=size_threshold)"}
{"task_id": "../test_cases/return_hello_world.ipynb", "completion": "\n    return \"hello world\"", "full_response": "\n    return \"hello world\""}
{"task_id": "../test_cases/rgb_to_grey_image_transform.ipynb", "completion": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image", "full_response": "\n    rgb_sum = r + g + b\n    r = r / rgb_sum\n    g = g / rgb_sum\n    b = b / rgb_sum\n    \n    import numpy as np\n    channel_r = np.asarray(rgb_image)[...,0]\n    channel_g = np.asarray(rgb_image)[...,1]\n    channel_b = np.asarray(rgb_image)[...,2]\n    grey_image = channel_r * r + \\\n                 channel_g * g + \\\n                 channel_b * b\n    \n    return grey_image"}
{"task_id": "../test_cases/rotate_image_by_90_degrees.ipynb", "completion": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)", "full_response": "\n    import pyclesperanto_prototype as cle\n    return cle.rotate(image, angle_around_z_in_degrees=90)"}
{"task_id": "../test_cases/subsample_image.ipynb", "completion": "\n    return image[::n,::n]", "full_response": "\n    return image[::n,::n]"}
{"task_id": "../test_cases/subtract_background_tophat.ipynb", "completion": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image", "full_response": "\n    from skimage.morphology import white_tophat\n    from skimage.morphology import disk\n    filtered_image = white_tophat(image, footprint=disk(radius))\n    \n    return filtered_image"}
{"task_id": "../test_cases/sum_images.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)", "full_response": "\n    import numpy as np\n    return np.asarray(image1) + np.asarray(image2)"}
{"task_id": "../test_cases/sum_intensity_projection.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)", "full_response": "\n    import numpy as np\n    return np.asarray(image).sum(axis=0)"}
{"task_id": "../test_cases/tiled_image_processing.ipynb", "completion": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result", "full_response": "\n    import dask\n    import dask.array as da\n\n    tiles = da.from_array(image, chunks=(tile_size, tile_size))\n    \n    def procedure(image):\n        from scipy.ndimage import maximum_filter\n        return maximum_filter(image, size=radius*2+1)\n\n    # setup a lazy result (not computed yet)\n    tile_map = da.map_blocks(procedure, tiles)\n\n    # actually apply filter\n    result = tile_map.compute()\n\n    return result"}
{"task_id": "../test_cases/transpose_image_axes.ipynb", "completion": "\n    import numpy as np\n    return np.asarray(image).T", "full_response": "\n    import numpy as np\n    return np.asarray(image).T"}
{"task_id": "../test_cases/t_test.ipynb", "completion": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    ", "full_response": "\n    import scipy\n    data1 = dataframe[column1]\n    data2 = dataframe[column2]\n    return scipy.stats.ttest_rel(data1, data2)[1]\n    "}
{"task_id": "../test_cases/workflow_batch_process_folder_count_labels.ipynb", "completion": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result", "full_response": "\n    import os\n    from skimage.io import imread\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(folder_location) if str(fn[-4:]) in supported_fileendings]\n    result = {}\n\n    for filename in file_list:\n        image = imread(folder_location + filename)\n\n        labels = np.unique(image).tolist()\n        labels.pop(0)\n\n        count = len(labels)\n\n        result[filename] = count\n\n    return result"}
{"task_id": "../test_cases/workflow_batch_process_folder_measure_intensity.ipynb", "completion": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)", "full_response": "\n    import os\n    import pandas as pd\n    from skimage.io import imread\n    from skimage.measure import regionprops\n    import numpy as np\n\n    supported_fileendings = [\".tif\", \".jpg\", \".png\"]    \n    file_list = [fn for fn in os.listdir(image_folder_location) if str(fn[-4:]) in supported_fileendings]\n\n    result = []\n\n    for filename in file_list:\n        image = imread(image_folder_location + filename)[...,0]\n        labels = imread(labels_folder_location + filename)\n\n        stats = regionprops(labels, intensity_image=image)\n\n        for s in stats:\n            result.append({\n                \"filename\":filename,\n                \"label\":s.label,\n                \"min_intensity\":s.min_intensity,\n                \"mean_intensity\":s.mean_intensity,\n                \"max_intensity\":s.max_intensity,\n            })\n\n    return pd.DataFrame(result)"}
{"task_id": "../test_cases/workflow_segmentation_counting.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()", "full_response": "\n    import skimage\n    import numpy as np\n    average_intensity = np.asarray(image).mean()\n    binary = image > average_intensity\n    labels = skimage.measure.label(binary)\n    return labels.max()"}
{"task_id": "../test_cases/workflow_segmentation_measurement_summary.ipynb", "completion": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)", "full_response": "\n    import skimage\n    import numpy as np\n    binary_image = image > skimage.filters.threshold_otsu(image)\n    label_image = skimage.measure.label(binary_image)\n    stats = skimage.measure.regionprops(label_image)\n    areas = [s.area for s in stats]\n    return np.mean(areas)"}
{"task_id": "../test_cases/workflow_segment_measure_umap.ipynb", "completion": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe", "full_response": "\n    import numpy as np\n    import pandas as pd\n    import umap\n    from skimage.measure import label, regionprops_table\n\n    image = np.asarray(image)\n\n    # segment\n    binary = image > 0.5 * image.max()\n    labels = label(binary)\n\n    # measure\n    dataframe = pd.DataFrame(regionprops_table(labels, intensity_image=image, \n                                              properties=['area', 'perimeter', 'mean_intensity', \n                                                          'minor_axis_length', 'major_axis_length']))\n\n    # append UMAP\n    embedding = umap.UMAP().fit_transform(dataframe)\n    dataframe['umap0'] = embedding[:,0]\n    dataframe['umap1'] = embedding[:,1]\n\n    return dataframe"}
{"task_id": "../test_cases/workflow_watershed_segmentation_correction_measurement.ipynb", "completion": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()", "full_response": "\n    import skimage\n    blurred = skimage.filters.gaussian(image, sigma=1)\n    minima = skimage.morphology.local_minima(blurred)\n    spots = skimage.measure.label(minima)\n    labels = skimage.segmentation.watershed(blurred, spots)\n    labels_without_border = skimage.segmentation.clear_border(labels)   \n    binary = labels_without_border > 0\n    return binary.sum()"}
